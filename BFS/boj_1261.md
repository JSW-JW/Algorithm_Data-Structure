# 백준 1261 알고스팟

#### 이 문제를 dfs 로 푸는 것은 시간복잡도가 기하급수적으로 증가할 수 있기 때문에 좋지않음.
#### 하지만, 1. ans 와 broken 을 비교하여 백트래킹,  2. broken_arr 와 broken 을 비교하여 백트래킹  
#### 을 시도하였음 (시간 초과)

```python
import sys
input = sys.stdin.readline

MAX = 1e9

m,n = map(int, input().split()) # m: 가로 , n: 세로
g = [[int(i) for i in input().rstrip()] for _ in range(n)]
nd = [(0, 1), (1, 0), (0, -1), (-1, 0)]
v = [[0] * m for _ in range(n)]
ans = MAX
broken_arr = [[MAX] * m for _ in range(n)]

def dfs(r, c, broken):
    global g
    global ans
    if broken_arr[r][c] < broken: return
    broken_arr[r][c] = broken
    if r == n-1 and c == m-1: return broken
    if broken >= ans: return

    for i in range(4):
        n_row = r + nd[i][0]
        n_col = c + nd[i][1]
        if n_row < 0 or n_row >= n or n_col < 0 or n_col >= m: continue
        if v[n_row][n_col] == 1: continue

        v[n_row][n_col] = 1
        res = dfs(n_row, n_col, broken + g[n_row][n_col])
        v[n_row][n_col] = 0
        if res is not None:
            ans = min(res, ans)


v[0][0] = 1
dfs(0, 0, 0)
print(ans)
```
